
定义:

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns


`Vue数据双向绑定（响应式系统）的实现原理`

> get的时候进行依赖收集，set的时候通知更新

```
    // observe方法遍历并包装对象属性
    function observe(target) {
        // 若target是一个对象，则遍历它
        if(target && typeof target === 'object') {
            Object.keys(target).forEach((key)=> {
                // defineReactive方法会给目标属性装上“监听器”
                defineReactive(target, key, target[key])
            })
        }
    }

    // 定义defineReactive方法
    function defineReactive(target, key, val) {
        // 属性值也可能是object类型，这种情况下需要调用observe进行递归遍历
        observe(val)
        // 为当前属性安装监听器
        Object.defineProperty(target, key, {
            // 可枚举
            enumerable: true,
            // 不可配置
            configurable: false, 
            get: function () {
                return val;
            },
            // 监听器函数
            set: function (value) {
                console.log(`${target}属性的${key}属性从${val}值变成了了${value}`)
                val = value
            }
        });
    }

    // 定义订阅者类Dep
    class Dep {
        constructor() {
            // 初始化订阅队列
            this.subs = []
        }
        
        // 增加订阅者
        addSub(sub) {
            this.subs.push(sub)
        }
        
        // 通知订阅者（是不是所有的代码都似曾相识？）
        notify() {
            this.subs.forEach((sub)=>{
                sub.update()
            })
        }
    }

    function defineReactive(target, key, val) {
        const dep = new Dep()
        // 监听当前属性
        observe(val)
        Object.defineProperty(target, key, {
            set: (value) => {
                // 通知所有订阅者
                dep.notify()
            }
        })
    }
```

`实现一个Event Bus/ Event Emitter`

```
    class EventEmitter{
        constructor(){
            this.handlers = {}
        }

        on(eventName,cb){
            if(!this.handlers[eventName]){
                this.handlers[eventName] = []
            }
            this.handlers[eventName].push(cb)
        }

        emit(eventName,...args){
            if(this.handlers[eventName]){
                this.handlers[eventName].forEach(cb=>cb(...args))
            }
        }

        off(eventName,cb){
            const callbacks = this.handlers[eventName]
            const index = callbacks.indexOf(cb)
            if(index!==-1){
                callbacks.splice(index,1)
            }
        }

        once(eventName,cb){
            const wrapper = (...args) => {
                cb.apply(...args)
                this.off(eventName,wrapper)
            }

            this.on(eventName,wrapper)
        }
    }
```

`观察者模式与发布-订阅模式的区别是什么？`

发布者直接触及到订阅者的操作，叫观察者模式

发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式。





