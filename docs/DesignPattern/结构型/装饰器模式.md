在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求

`装饰类`

```
    // 装饰器函数，第一个参数是目标类
    function classDecorator(target){
        target.hasDecorator = true
        return target
    }
    @classDecorator
    class Button{

    }

    console.log('Button是否被装饰了',Button.hasDecorator)
```

`装饰类中的方法`
> 为什么是原型对象，这是因为 onClick 方法总是要依附其实例存在的，修饰 onClik 其实是修饰它的实例。但我们的装饰器函数执行的时候，Button 实例还并不存在。为了确保实例生成后可以顺利调用被装饰好的方法，装饰器只能去修饰 Button 类的原型对象

```
    // target代表当前类的原型
    function funcDecorator(target,name,descriptor){
        let originalMethod = descriptor.value
        descriptor.value = function(){
            console.log('我是func的装饰器逻辑')
            return originalMethod.apply(this,arguments)
        }
        return descriptor
    }
    class Button{
        @funcDecorator
        onClick(){
            console.log('xxxx')
        }
    }

    const button = new Button()
    button.onClick()
```

`实际运用`

HOC
> HOC (Higher Order Component) 即高阶组件。它是装饰器模式在 React 中的实践，同时也是 React 应用中非常重要的一部分。通过编写高阶组件，我们可以充分复用现有逻辑，提高编码效率和代码的健壮性

```
    import React,{Component} from 'react'

    const BorderHoc = WrappedComponent => class extends Component{
        render(){
            return <div style={{border:'1px solid red'}}>
                <WrappedComponent/>
            </div>
        }
    }


    // 装饰目标组件

    import React, { Component } from 'react'
    import BorderHoc from './BorderHoc'

    @BorderHoc
    class TargetComponent extends React.Component{
        render(){

        }
    }

    export default TargetComponent
```
